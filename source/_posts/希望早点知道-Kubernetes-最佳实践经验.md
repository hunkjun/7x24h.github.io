---
title: 希望早点知道 Kubernetes 最佳实践经验
date: 2025-02-14 13:46:57
tags:
---

## 希望早点知道 Kubernetes 最佳实践经验

Kubernetes 无疑改变了我们构建、发布和运行应用程序的方式。但说实话，开始使用 Kubernetes 就像穿着人字拖攀登珠穆朗玛峰一样困难。

作为一名云原生公民和 Kubernetes 爱好者，我通过惨痛经历了解到，有很多“希望我早点知道”的最佳实践。它们可以节省我的时间、金钱和麻烦。

![](https://www.pulumi.com/blog/kubernetes-best-practices-i-wish-i-had-known-before/img.png)

“Kubernetes 很简单”的冰山模因是 Kubernetes 看似复杂的典型例子

在这篇文章中，我将重点介绍一些关键的 Kubernetes 最佳实践。它们来自我多年在生产中使用 Kubernetes 的经验。你可以将其视为你希望从第一天开始就拥有的精选“Kubernetes 备忘单”。

系好安全带；这将是一次激动人心的旅程。

## 1. 不要吝惜资源请求和限制

Kubernetes 中第一个“顿悟”的时刻就是意识到你可以定义容器请求的 CPU 和内存量（保证的资源）以及限制（允许的最大资源量）。

这里有一个棘手的部分：跳过这些设置可能会给你带来麻烦。

**资源请求**：这基本上是容器的基线。

如果您的容器请求 200m CPU 和 512Mi 内存，Kubernetes 调度程序会将您的 Pod 放置在至少具有这么多可用容量的节点上。

**资源限制**：这是上限。

如果您的容器试图超出限制，它可能会受到限制（CPU）甚至被驱逐（内存）。

**专业提示**：

从一些基线开始，可能是 100-200m CPU、128-512Mi 内存，然后在收集更多数据时进行调整。利用 Prometheus 或 Datadog 等监控工具分析实际使用情况并根据需要进行调整。

## 2. 命名空间就像你的生命依赖它一样

如果您将所有内容都部署到默认命名空间中，那么天哪，是时候进行干预了。

命名空间是一种简单但功能强大的机制，用于组织（和隔离）集群中的资源。

基于团队的命名空间：Dev、QA、Prod 或每个微服务（如果有意义）。

**访问控制**：将命名空间与 RBAC（基于角色的访问控制）策略相结合，以确保只有合适的人（和服务）才能访问您的内容。

**资源配额**：您可以为每个命名空间设置配额（例如，CPU，内存），防止一个流氓微服务占用所有资源。

退一步考虑并设计你的命名空间策略；未来你会说谢谢。

## 3.除非必要，否则避免在一个 Pod 中运行多个容器

是的，一个 Pod 可以包含多个容器。但应该这样做吗？通常，只有当多个容器紧密耦合且必须共享卷或网络命名空间等资源（例如，用于日志记录或安全代理的 sidecar 模式）时，您才希望将它们放在同一个 Pod 中。

为什么要避免使用多容器 Pod？

**复杂性**：对单个 Pod 中的多个容器进行故障排除可能很麻烦。

**耦合**：您失去了独立扩展容器的优势。如果您需要扩展一个容器，那么您最终会扩展该 Pod 中的所有容器。

遵循“每个 Pod 一个容器”的经验法则，除非你有令人信服的理由（例如 sidecar 模式）。

## 4. 使用包管理器管理你的 YAML 文件

在多个微服务中手动处理一百个 YAML 文件就像在凌晨 3 点调试意大利面条式代码一样有趣，这时就需要使用 Helm、Kustomize 或 Timoni 等工具了。

- Helm：“Kubernetes 的包管理器”。它使用可以通过值自定义的图表（模板）。

- Kustomize：一个原生 Kubernetes 工具，可让你在基本 YAML 清单上覆盖更改。

- Timoni：Timoni 是 Kubernetes 的包管理器，由 CUE 提供支持并受到 Helm 的启发。

专业提示：如果您是 Helm 新手，请先从 Helm Hub 或 Artifact Hub 的官方图表开始。然后根据自己的喜好进行自定义。这样您就可以免于 YAML 重复的困扰。

## 5. 入口和网络最佳实践

在 Kubernetes 中，网络很快就会变得复杂。服务、入口控制器和负载均衡器之间很容易出现混乱。请记住以下几点：

- 使用 Ingress Controller / Gateway API（NGINX、Traefik、HAProxy、Istio Gateway 等）来管理外部访问。
- 利用基于路径和基于子域的路由来简化您的网络拓扑。
- TLS 终止：在入口层终止 SSL/TLS。您可以卸载证书管理（例如通过 cert-manager）并确保集群流量安全高效。
- Ingress 是 Kubernetes 中一个强大的概念，花点时间正确设置它。混乱的 Ingress 配置就像一条坑坑洼洼的车道，通向一座美丽的豪宅。

## 6. 依靠活跃度、就绪度和启动探测
Kubernetes 有点像个人助理，但它需要明确的指示。如果没有正确配置存活、就绪和启动探测，您的集群将无法判断容器的健康状况。

- 存活探测：检查容器是否存活。如果失败，Kubernetes 将重新启动容器。
- 就绪探测：检查容器是否已准备好提供流量。在准备就绪之前，容器不会获得流量。
- 启动探测：对于需要一段时间才能启动的应用程序很有用。它可以防止容器在初始加载期间过早被终止。

**专业提示**：先进行就绪性探测，再进行活跃性探测。您肯定不希望容器因为尚未就绪而被终止。请微调阈值、周期和超时参数。

## 7. 注意安全：RBAC、Pod 安全性和 Secrets

安全性对 Kubernetes 来说不仅仅是锦上添花，更是至关重要。如果您的集群受到攻击，一切就都结束了。

- RBAC（基于角色的访问控制）：

从第一天开始就实施它。使用最小特权原则。仅向每个用户、服务帐户或应用程序授予其所需的访问权限。

- Pod 安全：

使用Pod Security Admission功能来强制执行标准（例如，不允许特权容器）。确保除非绝对必要，否则不要以 root 身份运行容器。

- 妥善管理秘密：

不要将凭证或 API 密钥以纯文本形式存储在容器映像或环境变量中。

不要使用 Kubernetes Secrets，而是使用External Secret Operator或Secret Store CSI Driver将机密存储在外部机密存储中，例如AWS Secrets Manager、Pulumi ESC或HashiCorp Vault。

## 8. 监控一切（然后再监控更多）

Kubernetes 中的监控不是可选的，而是强制性的。随着容器的出现和消失，您需要强大的可观察性来查看幕后发生的事情。

- Prometheus + Grafana：指标和仪表板的经典组合。
- ELK / EFK / Grafana Loki Stack：用于日志的 Elastic（或 OpenSearch），以及用于日志收集的 Kibana 和 Fluentd/Fluent Bit 或用于日志的 Grafana Loki。
- Jaeger / Zipkin / Tempo：如果您有相互调用的微服务，则用于分布式跟踪。

尽早设置警报。您肯定不希望半夜时分，愤怒的用户向您发来“为什么应用程序这么慢？”这样的第一个问题信号。

## 9. 使用 CI/CD 实现自动化部署
Kubernetes 的最大优势之一是它使整个发布流程自动化变得更加容易。如果您仍在进行手动部署，那么现在是时候转向 CI/CD 管道了。

- Jenkins、GitLab、GitHub Actions，选择权在您手中。
- 拥抱GitOps ：将所有清单存储在 Git 中，并让Flux或Argo CD等工具将它们同步到您的集群。
- 如果部署失败则自动回滚。

自动化不仅加快了交付速度，而且大大减少了人为错误的发生。

## 10.保持 Kubernetes 集群和组件更新

运行过时的 Kubernetes 版本就像在 2025 年使用运行 iOS 6 的手机一样。不建议这样做。

Kubernetes 发布周期：大约每三个月发布一次小版本，补丁发布频率也更高。
**升级策略**：

首先在开发环境中进行测试。

备份你的 etcd（键值存储）。

升级控制平面，然后升级工作节点，或者使用为您处理部分内容的托管服务（例如 EKS、GKE、AKS）。

保持您的依赖项更新（例如，容器运行时、CNI 插件等）以从最新的安全和性能改进中受益。

## 11.明智地使用标签和注释
标签和注释乍一看可能微不足道，但对于组织良好的集群来说，它们却是至关重要的。

- 标签：用于分组和选择 Kubernetes 对象的键值对。例如，app=my-app、env=staging、team=payments。

- 注释：用于附加非识别元数据（例如版本信息、联系电子邮件或上次部署的时间戳）的键值对。

一致的标签策略可帮助您快速筛选资源并维护清晰的集群思维导图。

## 12.采用多环境方法

如果您的开发、准备和生产环境共享一个集群，那么您就是在玩火。虽然可以做到这一点，但最佳做法是将生产工作负载与操场隔离开来。

- 独立集群：至少有一个集群用于开发/准备，一个集群用于生产。有创建工具（如vCluster）可以在单个集群内创建虚拟集群。
- 命名空间隔离：如果必须在同一个集群中运行它们，请使用严格的基于命名空间的隔离和 RBAC 规则。

保持环境分离可以降低风险并使得在沙箱中测试新功能变得更加容易。

## 13. 优化你的容器镜像

- 不要发送包含一半 Ubuntu 和随机剩余内容的庞大容器镜像。这会导致部署缓慢和资源浪费。
- 使用轻量级基础镜像，如distroless、alpine 或基于最小操作系统的镜像。
- 清理 Dockerfiles 中的临时文件和依赖项。
- 使用Trivy或Anchore等工具定期扫描图像中是否存在漏洞。
- 更小的图像 = 更快的拉取时间 = 更少的扩展应用程序的时间 = 更好的用户体验。

## 14. 实施可靠的日志记录策略

日志是您进行故障排除的首选——在 Kubernetes 中，您需要一个可以处理临时 Pod 的解决方案。

- 集中式日志记录：无论是 ELK/EFK、Splunk 还是托管服务，请确保日志不仅仅位于临时容器存储中。
- 结构化日志：JSON 或其他结构化格式可帮助您的日志系统更有效地解析和过滤日志。
- 日志保留和轮换：定义明确的策略以防止日志存储膨胀。

相信我，你不会想在生产事故发生时争先恐后地寻找日志。


## 15. 像对待牛而不是宠物一样对待 Kubernetes

有句老话适用于服务器：“像对待牛一样对待它们，而不是宠物”也适用于 Kubernetes。

不要依赖手动修复或人工干预。尽可能争取不可变的基础设施：

如果 Pod 出现问题，请在 YAML、代码或容器镜像中修复它，重新部署，然后删除旧的 Pod。

避免对正在运行的容器进行偷偷摸摸的“快速修复”——这些更改将在 Kubernetes 重新启动 Pod 时消失。

拥抱临时环境和动态扩展。这就是 Kubernetes 最擅长的！

## 16.考虑采用更高级别的方法进行复杂部署

虽然原生 YAML 清单可以用于较小的 Kubernetes 部署，但随着项目和团队的增长，它们往往会变得难以处理。Pulumi为部署自动化提供了强大的替代方案，它提供：

- 真正的编程语言：使用 TypeScript、JavaScript、Python、Go、Java 或 C#实现类型安全、可测试的基础架构代码。
- 跨云灵活性：使用单一工具管理跨多个云提供商和 Kubernetes 的资源。
- 可重用模块：将常见模式抽象为可重用组件，减少样板并防止偏差。
- 强大的工具和生态系统：受益于包管理器、IDE 集成和丰富的共享 Pulumi 组件库。

通过采用 Pulumi，您可以避免处理无尽 YAML 文件的复杂性，并为您的 Kubernetes 基础设施获得更简化、更易于维护的工作流程。

## 最后的想法

![](https://www.pulumi.com/blog/kubernetes-best-practices-i-wish-i-had-known-before/img_2.png)

Kubernetes 就像一把瑞士军刀：

功能强大、用途广泛，但如果不小心也容易被误用。

通过采用这些最佳实践、声明式配置、合理的资源分配、强大的安全性、强大的可观察性和自动化部署，您将保持集群平稳运行。

如果你已经从痛苦中吸取了一些教训，那么你并不孤单。但 Kubernetes 的美妙之处在于，每次挫折都会让你获得更多经验来调整你的方法。

让我们一起学习（并忘掉所学），这样我们就可以像专业人士一样继续驯服这头 Kubernetes 猛兽。

